<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SMC Crypto Trading OS (Cloud v1 + Analytics)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --bg: #020617;
      --card-bg: #020617;
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.16);
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1e293b 0, #020617 40%, #020617 100%);
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.3fr);
      gap: 24px;
    }
    @media (max-width: 900px) {
      .app { grid-template-columns: minmax(0,1fr); }
    }

    .card {
      background: linear-gradient(145deg, #020617 0%, #020617 50%, #020617 100%);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 20px 20px 16px;
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(79, 70, 229, 0.18), transparent 60%);
      pointer-events: none;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 14px;
      position: relative;
      z-index: 1;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .card-subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      white-space: nowrap;
    }

    .prompt {
      position: relative;
      z-index: 1;
      margin-bottom: 16px;
      padding: 14px 14px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .prompt-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent);
      margin-bottom: 6px;
    }

    .prompt-text {
      font-size: 0.98rem;
      line-height: 1.5;
    }

    .note {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .options {
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 12px;
    }

    .btn {
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.85rem;
      border: 1px solid transparent;
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.14s ease-out;
    }
    .btn-primary {
      background: radial-gradient(circle at top left, #4f46e5, #4338ca);
      border-color: rgba(129, 140, 248, 0.9);
      box-shadow: 0 0 0 1px rgba(129, 140, 248, 0.2);
    }
    .btn-outline {
      border-color: rgba(148, 163, 184, 0.6);
    }
    .btn-ghost {
      border-color: transparent;
      background: transparent;
      color: var(--text-muted);
      padding-inline: 0;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.7);
      opacity: 0.97;
    }
    .btn:active {
      transform: translateY(0);
      box-shadow: none;
      opacity: 0.9;
    }

    .status-line {
      font-size: 0.8rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-top: 6px;
      position: relative;
      z-index: 1;
    }

    .flow {
      position: relative;
      z-index: 1;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(148, 163, 184, 0.4);
      font-size: 0.8rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .summary {
      position: relative;
      z-index: 1;
      margin-top: 10px;
      padding: 10px 12px 8px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px dashed rgba(148, 163, 184, 0.5);
      font-size: 0.8rem;
    }

    .summary-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .summary-item {
      margin-bottom: 2px;
    }

    .meta {
      position: relative;
      z-index: 1;
      margin-top: 10px;
      padding: 8px 10px 6px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(55, 65, 81, 0.9);
      font-size: 0.78rem;
    }

    .meta-title {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .meta-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      flex-wrap: wrap;
    }

    .meta-label {
      color: var(--text-muted);
      min-width: 70px;
    }

    .meta-chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .meta-tf-btn {
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.75rem;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: #e5e7eb;
      cursor: pointer;
      transition: all 0.14s;
    }
    .meta-tf-btn.active {
      background: radial-gradient(circle at top left, #4f46e5, #4338ca);
      border-color: rgba(129,140,248,0.9);
    }

    .meta-select {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: #e5e7eb;
      font-size: 0.78rem;
    }

    .meta-notes-input {
      flex: 1;
      min-width: 140px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: #e5e7eb;
      font-size: 0.78rem;
    }

    .auth-bar {
      position: relative;
      z-index: 1;
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 0.78rem;
    }

    .auth-input {
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: #e5e7eb;
      font-size: 0.78rem;
      min-width: 130px;
    }

    .auth-status {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .journal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }

    .stats {
      display: flex;
      flex-direction: column;
      gap: 3px;
      font-size: 0.78rem;
      text-align: right;
      color: var(--text-muted);
    }

    .stats span {
      display: block;
    }

    .filter-bar {
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
      font-size: 0.78rem;
    }

    .filter-select {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: #e5e7eb;
      font-size: 0.78rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
      position: relative;
      z-index: 1;
    }

    th, td {
      padding: 6px 6px;
      text-align: left;
      border-bottom: 1px solid rgba(30, 41, 59, 0.85);
    }

    th {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    tbody tr:hover {
      background-color: rgba(15, 23, 42, 0.8);
    }

    .pill {
      display: inline-block;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .pill-win { background: rgba(34,197,94,0.16); color: #bbf7d0; }
    .pill-loss { background: rgba(239,68,68,0.16); color: #fecaca; }
    .pill-be { background: rgba(148,163,184,0.16); color: #e5e7eb; }

    .empty-state {
      font-size: 0.8rem;
      color: var(--text-muted);
      padding-top: 6px;
    }

    .charts-grid {
      position: relative;
      z-index: 1;
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 10px;
    }
    @media (max-width: 1100px) {
      .charts-grid {
        grid-template-columns: minmax(0,1fr);
      }
    }

    .chart-card {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(30, 64, 175, 0.7);
      padding: 6px 8px 4px;
    }

    .chart-title {
      font-size: 0.72rem;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    .insights {
      position: relative;
      z-index: 1;
      margin-top: 10px;
      padding: 8px 10px 6px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px dashed rgba(148, 163, 184, 0.7);
      font-size: 0.78rem;
      line-height: 1.4;
    }

    .insights-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="app">
    <!-- LEFT: WIZARD -->
    <div class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Crypto SMC Wizard</div>
          <div class="card-subtitle" id="node-type-label">Phase: â€“</div>
        </div>
        <div class="badge" id="bias-label">Bias: â€“</div>
      </div>

      <div class="prompt">
        <div class="prompt-label">Current Step</div>
        <div class="prompt-text" id="node-text">Loadingâ€¦</div>
        <div class="note" id="node-note"></div>
      </div>

      <div class="options" id="options-container"></div>

      <div class="status-line">
        <span id="status-line-text">Follow the steps. No skipping.</span>
        <div>
          <button class="btn btn-ghost" id="back-btn" type="button">âŸµ Back</button>
          <button class="btn btn-ghost" id="restart-btn" type="button">âŸ³ Restart</button>
        </div>
      </div>

      <div class="flow">
        <strong>Flow:</strong> Context â†’ HTF Bias â†’ Zone â†’ Entry â†’ Risk â†’ Save trade.  
        This version is crypto-only; Firestore sync is enabled when logged in.
      </div>

      <div class="summary" id="summary-panel">
        <div class="summary-title">Current Trade Plan (Draft)</div>
        <div class="summary-item" id="summary-pair">Pair: â€“</div>
        <div class="summary-item" id="summary-session">Session: â€“</div>
        <div class="summary-item" id="summary-bias">HTF Bias: â€“</div>
        <div class="summary-item" id="summary-displacement">Displacement: â€“</div>
        <div class="summary-item" id="summary-zone">Zone Type: â€“</div>
        <div class="summary-item" id="summary-entry">Entry Type: â€“</div>
        <div class="summary-item" id="summary-sl">SL Method: â€“</div>
        <div class="summary-item" id="summary-tp">TP Method: â€“</div>
        <div class="summary-item" id="summary-tf">Entry TF: â€“</div>
        <div class="summary-item" id="summary-tag">Tag: â€“</div>
        <div class="summary-item" id="summary-score">Setup Score: â€“</div>
      </div>

      <div class="meta" id="meta-panel">
        <div class="meta-title">Meta (used for stats & filtering)</div>

        <div class="meta-row">
          <span class="meta-label">Entry TF:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn" data-tf="1m">1m</button>
            <button type="button" class="meta-tf-btn" data-tf="3m">3m</button>
            <button type="button" class="meta-tf-btn" data-tf="5m">5m</button>
            <button type="button" class="meta-tf-btn" data-tf="15m">15m</button>
          </div>
        </div>

        <div class="meta-row">
          <span class="meta-label">Setup tag:</span>
          <select id="meta-tag-select" class="meta-select">
            <option value="">â€“</option>
            <option value="HTF reversal">HTF reversal</option>
            <option value="HTF continuation">HTF continuation</option>
            <option value="LTF continuation">LTF continuation</option>
            <option value="News fade">News fade</option>
            <option value="Liquidity grab scalp">Liquidity grab scalp</option>
          </select>
        </div>

        <div class="meta-row">
          <span class="meta-label">Notes:</span>
          <input id="meta-notes" class="meta-notes-input" type="text" placeholder="Optional notes (missed first touch, late entry, etc.)" />
        </div>
      </div>

      <div class="options" id="save-container" style="margin-top: 10px;"></div>
    </div>

    <!-- RIGHT: AUTH + CONTEXT + JOURNAL + ANALYTICS -->
    <div class="card">
      <div class="auth-bar">
        <input class="auth-input" id="auth-email" type="email" placeholder="Email" />
        <input class="auth-input" id="auth-password" type="password" placeholder="Password" />
        <button class="btn btn-outline" id="login-btn" type="button">Login</button>
        <button class="btn btn-outline" id="register-btn" type="button">Register</button>
        <button class="btn btn-ghost" id="logout-btn" type="button">Logout</button>
        <span class="auth-status" id="auth-status">Not logged in (local mode)</span>
      </div>

      <!-- Daily Market Context -->
      <div class="meta" id="daily-context-panel">
        <div class="meta-title">Daily Market Context</div>

        <div class="meta-row">
          <span class="meta-label">BTC HTF:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcHTFTrend" data-dc-value="bullish">Bullish</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcHTFTrend" data-dc-value="bearish">Bearish</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcHTFTrend" data-dc-value="range">Range</button>
          </div>
        </div>

        <div class="meta-row">
          <span class="meta-label">BTC intraday:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcLTFState" data-dc-value="pumping">Pumping</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcLTFState" data-dc-value="dumping">Dumping</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcLTFState" data-dc-value="grindy">Grindy</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcLTFState" data-dc-value="choppy">Choppy</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcLTFState" data-dc-value="flat">Flat</button>
          </div>
        </div>

        <div class="meta-row">
          <span class="meta-label">Regime:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="regime" data-dc-value="macro bull">Macro bull</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="regime" data-dc-value="macro bear">Macro bear</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="regime" data-dc-value="sideways">Sideways</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="regime" data-dc-value="accumulation">Accumulation</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="regime" data-dc-value="distribution">Distribution</button>
          </div>
        </div>

        <div class="meta-row">
          <span class="meta-label">Fear/Greed:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="fearGreedBucket" data-dc-value="extreme fear">Ext fear</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="fearGreedBucket" data-dc-value="fear">Fear</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="fearGreedBucket" data-dc-value="neutral">Neutral</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="fearGreedBucket" data-dc-value="greed">Greed</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="fearGreedBucket" data-dc-value="extreme greed">Ext greed</button>
          </div>
        </div>

        <div class="meta-row">
          <span class="meta-label">Volatility:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="volatility" data-dc-value="low">Low</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="volatility" data-dc-value="normal">Normal</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="volatility" data-dc-value="high">High</button>
          </div>
        </div>

        <div class="meta-row">
          <span class="meta-label">Dominance:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcDominanceTrend" data-dc-value="up">Up</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcDominanceTrend" data-dc-value="down">Down</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="btcDominanceTrend" data-dc-value="flat">Flat</button>
          </div>
        </div>

        <div class="meta-row">
          <span class="meta-label">News:</span>
          <div class="meta-chip-group">
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="newsImpact" data-dc-value="none">None</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="newsImpact" data-dc-value="scheduled">Scheduled</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="newsImpact" data-dc-value="unexpected">Unexpected</button>
            <button type="button" class="meta-tf-btn dc-btn" data-dc-field="newsImpact" data-dc-value="post-event">Post-event</button>
          </div>
        </div>

        <div class="meta-row">
          <button class="btn btn-outline" id="dc-save-btn" type="button">Save Today&#39;s Context</button>
          <span class="auth-status" id="dc-status">No context set for today.</span>
        </div>
      </div>

      <div class="journal-header">
        <div>
          <div class="card-title">Journal</div>
          <div class="card-subtitle">Local when logged out. Cloud when logged in.</div>
        </div>
        <div class="stats">
          <span id="stats-total">Trades: 0</span>
          <span id="stats-winrate">Winrate: â€“</span>
          <span id="stats-avgR">Avg R: â€“</span>
        </div>
      </div>

      <div class="filter-bar">
        <select id="filter-session" class="filter-select">
          <option value="">Session: All</option>
          <option value="London">London</option>
          <option value="New York">New York</option>
          <option value="Asia">Asia</option>
          <option value="Off-hours">Off-hours</option>
        </select>

        <select id="filter-zone" class="filter-select">
          <option value="">Zone: All</option>
          <option value="reversal">Reversal</option>
          <option value="continuation">Continuation</option>
        </select>

        <select id="filter-entry" class="filter-select">
          <option value="">Entry: All</option>
          <option value="confirmation">Confirmation</option>
          <option value="limit">Limit</option>
        </select>

        <select id="filter-result" class="filter-select">
          <option value="">Result: All</option>
          <option value="win">Win</option>
          <option value="loss">Loss</option>
          <option value="be">B/E</option>
        </select>
      </div>

      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Pair</th>
            <th>TF</th>
            <th>Bias</th>
            <th>Zone</th>
            <th>Entry</th>
            <th>Tag</th>
            <th>Score</th>
            <th>Result</th>
            <th>R</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="journal-body"></tbody>
      </table>
      <div class="empty-state" id="journal-empty">No trades yet. Finish a wizard run and save.</div>

      <div class="charts-grid">
        <div class="chart-card">
          <div class="chart-title">Winrate by Session</div>
          <canvas id="sessionChart"></canvas>
        </div>
        <div class="chart-card">
          <div class="chart-title">Winrate by Score Bucket</div>
          <canvas id="scoreChart"></canvas>
        </div>
        <div class="chart-card">
          <div class="chart-title">R-multiple Distribution</div>
          <canvas id="rDistChart"></canvas>
        </div>
      </div>

      <div class="insights" id="insights-panel">
        <div class="insights-title">Pattern Insights</div>
        <div id="insights-content">Not enough data yet. Log more trades.</div>
      </div>

      <div style="margin-top: 8px; text-align: right; position: relative; z-index:1;">
        <button class="btn btn-outline" id="clear-btn" type="button">Clear All (local only)</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged,
      createUserWithEmailAndPassword,
      signInWithEmailAndPassword,
      signOut
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
    import {
      getFirestore,
      collection,
      addDoc,
      getDocs,
      query,
      where,
      orderBy,
      doc,
      updateDoc
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "YOUR_REDACTED_KEY_HERE",
      authDomain: "smc-trade-os.firebaseapp.com",
      projectId: "smc-trade-os",
      storageBucket: "smc-trade-os.firebasestorage.app",
      messagingSenderId: "565962124502",
      appId: "1:565962124502:web:891e9d125fd49f23052d77",
      measurementId: "G-LGTW0D5ZKQ"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUser = null;
    let tradesCache = [];
    let lastLoadedTrades = [];

    let sessionChart = null;
    let scoreChart = null;
    let rDistChart = null;

    const authEmailEl = document.getElementById("auth-email");
    const authPasswordEl = document.getElementById("auth-password");
    const loginBtnEl = document.getElementById("login-btn");
    const registerBtnEl = document.getElementById("register-btn");
    const logoutBtnEl = document.getElementById("logout-btn");
    const authStatusEl = document.getElementById("auth-status");

    const nodeTypeLabelEl = document.getElementById("node-type-label");
    const biasLabelEl = document.getElementById("bias-label");
    const nodeTextEl = document.getElementById("node-text");
    const nodeNoteEl = document.getElementById("node-note");
    const optionsContainerEl = document.getElementById("options-container");
    const saveContainerEl = document.getElementById("save-container");
    const statusLineTextEl = document.getElementById("status-line-text");
    const backBtnEl = document.getElementById("back-btn");
    const restartBtnEl = document.getElementById("restart-btn");

    const summaryPairEl = document.getElementById("summary-pair");
    const summarySessionEl = document.getElementById("summary-session");
    const summaryBiasEl = document.getElementById("summary-bias");
    const summaryDisplacementEl = document.getElementById("summary-displacement");
    const summaryZoneEl = document.getElementById("summary-zone");
    const summaryEntryEl = document.getElementById("summary-entry");
    const summarySlEl = document.getElementById("summary-sl");
    const summaryTpEl = document.getElementById("summary-tp");
    const summaryTfEl = document.getElementById("summary-tf");
    const summaryTagEl = document.getElementById("summary-tag");
    const summaryScoreEl = document.getElementById("summary-score");

    const journalBodyEl = document.getElementById("journal-body");
    const journalEmptyEl = document.getElementById("journal-empty");
    const clearBtnEl = document.getElementById("clear-btn");

    const statsTotalEl = document.getElementById("stats-total");
    const statsWinrateEl = document.getElementById("stats-winrate");
    const statsAvgREl = document.getElementById("stats-avgR");

    const metaTfButtons = document.querySelectorAll(".meta-tf-btn");
    const metaTagSelectEl = document.getElementById("meta-tag-select");
    const metaNotesEl = document.getElementById("meta-notes");

    const filterSessionEl = document.getElementById("filter-session");
    const filterZoneEl = document.getElementById("filter-zone");
    const filterEntryEl = document.getElementById("filter-entry");
    const filterResultEl = document.getElementById("filter-result");

    const sessionChartCtx = document.getElementById("sessionChart").getContext("2d");
    const scoreChartCtx = document.getElementById("scoreChart").getContext("2d");
    const rDistChartCtx = document.getElementById("rDistChart").getContext("2d");

    const insightsContentEl = document.getElementById("insights-content");

    // ===== Daily Market Context (per-day regime) =====
    const dcStatusEl = document.getElementById("dc-status");
    const dcSaveBtn = document.getElementById("dc-save-btn");
    const dcButtons = document.querySelectorAll(".dc-btn");

    let currentDailyContext = null;
    let dailyContextMap = {}; // { "YYYY-MM-DD": { ... } }

    function getTodayKey() {
      const d = new Date();
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function loadDailyContextLocal() {
      try {
        const raw = localStorage.getItem("dailyContext");
        if (!raw) {
          dailyContextMap = {};
          return;
        }
        dailyContextMap = JSON.parse(raw) || {};
      } catch {
        dailyContextMap = {};
      }
    }

    function saveDailyContextLocal() {
      try {
        localStorage.setItem("dailyContext", JSON.stringify(dailyContextMap));
      } catch {}
    }

    function ensureTodayContext() {
      const todayKey = getTodayKey();
      let ctx = dailyContextMap[todayKey];
      if (!ctx) {
        ctx = {
          date: todayKey,
          btcHTFTrend: null,
          btcLTFState: null,
          regime: null,
          fearGreedBucket: null,
          volatility: null,
          btcDominanceTrend: null,
          newsImpact: null
        };
        dailyContextMap[todayKey] = ctx;
      }
      currentDailyContext = ctx;
    }

    function updateDailyContextUI() {
      const todayKey = getTodayKey();
      if (!currentDailyContext || currentDailyContext.date !== todayKey) {
        dcStatusEl.textContent = "No context set for today.";
      } else {
        const ctx = currentDailyContext;
        const parts = [];
        if (ctx.regime) parts.push(ctx.regime);
        if (ctx.btcHTFTrend) parts.push("HTF " + ctx.btcHTFTrend);
        if (ctx.btcLTFState) parts.push("LTF " + ctx.btcLTFState);
        if (ctx.fearGreedBucket) parts.push("FG: " + ctx.fearGreedBucket);
        if (ctx.volatility) parts.push("Vol: " + ctx.volatility);
        if (ctx.btcDominanceTrend) parts.push("Dom: " + ctx.btcDominanceTrend);
        if (ctx.newsImpact) parts.push("News: " + ctx.newsImpact);
        dcStatusEl.textContent = parts.length ? parts.join(" | ") : "Context blank for today.";
      }

      dcButtons.forEach(btn => {
        const field = btn.getAttribute("data-dc-field");
        const val = btn.getAttribute("data-dc-value");
        if (
          currentDailyContext &&
          currentDailyContext.date === getTodayKey() &&
          currentDailyContext[field] === val
        ) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });
    }

    dcButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const todayKey = getTodayKey();
        if (!currentDailyContext || currentDailyContext.date !== todayKey) {
          ensureTodayContext();
        }
        const field = btn.getAttribute("data-dc-field");
        const val = btn.getAttribute("data-dc-value");

        if (currentDailyContext[field] === val) {
          currentDailyContext[field] = null;
        } else {
          currentDailyContext[field] = val;
        }

        dailyContextMap[todayKey] = currentDailyContext;
        saveDailyContextLocal();
        updateDailyContextUI();
      });
    });

    dcSaveBtn.addEventListener("click", () => {
      const todayKey = getTodayKey();
      if (!currentDailyContext || currentDailyContext.date !== todayKey) {
        ensureTodayContext();
      }
      dailyContextMap[todayKey] = currentDailyContext;
      saveDailyContextLocal();
      updateDailyContextUI();
      alert("Saved today's market context (" + todayKey + ").");
    });

    function hasAnyDailyContext(ctx) {
      if (!ctx) return false;
      return !!(
        ctx.btcHTFTrend ||
        ctx.btcLTFState ||
        ctx.regime ||
        ctx.fearGreedBucket ||
        ctx.volatility ||
        ctx.btcDominanceTrend ||
        ctx.newsImpact
      );
    }

    // ===== Wizard nodes =====
    const nodes = {
      start: {
        id: "start",
        type: "context",
        text: "What pair are you planning to trade?",
        note: "You can add more pairs later. For now, pick the closest match.",
        field: "pair",
        options: [
          { label: "BTCUSDT", value: "BTCUSDT", next: "session", branchLabel: "Pair: BTCUSDT" },
          { label: "ETHUSDT", value: "ETHUSDT", next: "session", branchLabel: "Pair: ETHUSDT" },
          { label: "Altcoin / Other", value: "ALT", next: "session", branchLabel: "Pair: ALT/OTHER" }
        ]
      },

      session: {
        id: "session",
        type: "context",
        text: "What session are you mainly trading this setup in?",
        note: "This will matter later when you analyze performance by session.",
        field: "session",
        options: [
          { label: "London", value: "London", next: "htfSweep", branchLabel: "Session: London" },
          { label: "New York", value: "New York", next: "htfSweep", branchLabel: "Session: New York" },
          { label: "Asia", value: "Asia", next: "htfSweep", branchLabel: "Session: Asia" },
          { label: "Weekend / Random", value: "Off-hours", next: "htfSweep", branchLabel: "Session: Off-hours" }
        ]
      },

      htfSweep: {
        id: "htfSweep",
        type: "htf",
        text: "On HTF (1H/4H), did price sweep a clear liquidity pool (equal highs/lows or a clear prior swing)?",
        note: "If not, youâ€™re early. Usually better to wait for liquidity to be taken first.",
        field: "htfSweep",
        options: [
          { label: "Yes, clear sweep", value: "yes", next: "displacementType", branchLabel: "HTF Sweep: YES" },
          { label: "No, nothing obvious", value: "no", next: "infoNoSweep", branchLabel: "HTF Sweep: NO" }
        ]
      },

      infoNoSweep: {
        id: "infoNoSweep",
        type: "info",
        text: "No clear HTF sweep = low-quality context.",
        note: "Youâ€™re probably the liquidity if you trade now. Better to restart and wait for sweep.",
        options: [
          { label: "Restart & wait for sweep", next: "start", branchLabel: "Restart after no sweep" }
        ]
      },

      displacementType: {
        id: "displacementType",
        type: "htf",
        text: "How did price move after the sweep?",
        note: "Impulse: 1â€“3 big body candles with strong FVG. Staircase: multiple pushes with shallow pullbacks. Grindy: overlapping candles, messy.",
        field: "displacementType",
        options: [
          { label: "Impulse leg", value: "impulse", next: "bosDirection", branchLabel: "Displacement: Impulse" },
          { label: "Steplike pump / dump", value: "staircase", next: "bosDirection", branchLabel: "Displacement: Staircase" },
          { label: "Grindy / overlapping", value: "grindy", next: "infoWeakMove", branchLabel: "Displacement: Grindy/Weak" }
        ]
      },

      infoWeakMove: {
        id: "infoWeakMove",
        type: "info",
        text: "Grindy move after a sweep = low-quality context.",
        note: "If displacement is weak, the zone often fails or chops. Best not to force a trade here.",
        options: [
          { label: "Restart and wait for cleaner move", next: "start", branchLabel: "Restart after weak move" }
        ]
      },

      bosDirection: {
        id: "bosDirection",
        type: "htf",
        text: "Did price break structure (BOS) in the direction of that move?",
        note: "Bullish BOS â†’ you look for demand in discount. Bearish BOS â†’ you look for supply in premium.",
        field: "htfBias",
        options: [
          { label: "Bullish BOS (highs taken)", value: "bullish", next: "areaBull", branchLabel: "BOS: Bullish" },
          { label: "Bearish BOS (lows taken)", value: "bearish", next: "areaBear", branchLabel: "BOS: Bearish" },
          { label: "No clean BOS", value: "none", next: "infoNoBos", branchLabel: "BOS: None" }
        ]
      },

      infoNoBos: {
        id: "infoNoBos",
        type: "info",
        text: "No clean BOS = unclear HTF trend.",
        note: "Without trend direction, your SMC zones become random. Skip this setup.",
        options: [
          { label: "Restart & wait for clear BOS", next: "start", branchLabel: "Restart after no BOS" }
        ]
      },

      areaBull: {
        id: "areaBull",
        type: "htf",
        text: "For this bullish BOS, is price now in discount (lower part of the swing)?",
        note: "Demand only makes sense in discount. If you are trying to long in premium, thatâ€™s chasing.",
        field: "htfArea",
        options: [
          { label: "Yes, in discount", value: "discount", next: "zoneType", branchLabel: "Area: Bullish + Discount" },
          { label: "No, mid / premium", value: "wrong", next: "infoWrongArea", branchLabel: "Area: Bullish but wrong" }
        ]
      },

      areaBear: {
        id: "areaBear",
        type: "htf",
        text: "For this bearish BOS, is price now in premium (upper part of the swing)?",
        note: "Supply only makes sense in premium. Shorting discount is risky.",
        field: "htfArea",
        options: [
          { label: "Yes, in premium", value: "premium", next: "zoneType", branchLabel: "Area: Bearish + Premium" },
          { label: "No, mid / discount", value: "wrong", next: "infoWrongArea", branchLabel: "Area: Bearish but wrong" }
        ]
      },

      infoWrongArea: {
        id: "infoWrongArea",
        type: "info",
        text: "You have bias, but price is in the wrong part of the swing.",
        note: "Trading mid-range is gambling. You either wait for price to move to discount/premium or skip.",
        options: [
          { label: "Restart & wait for correct area", next: "start", branchLabel: "Restart from wrong area" }
        ]
      },

      zoneType: {
        id: "zoneType",
        type: "zone",
        text: "What zone are you trying to trade?",
        note: "Reversal at HTF extreme â†’ confirmation entry. Continuation mid-trend â†’ limit is acceptable.",
        field: "zoneType",
        options: [
          { label: "Reversal zone (HTF extreme)", value: "reversal", next: "entryType", branchLabel: "Zone: Reversal" },
          { label: "Continuation zone (trend continuation)", value: "continuation", next: "entryType", branchLabel: "Zone: Continuation" }
        ]
      },

      entryType: {
        id: "entryType",
        type: "entry",
        text: "How do you intend to enter this trade?",
        note: "Reversal + crypto = safer to use LTF confirmation. Strong continuation in obvious trend = limit can work.",
        field: "entryType",
        options: [
          { label: "Confirmation (LTF sweep + CHOCH + OB)", value: "confirmation", next: "slMethod", branchLabel: "Entry: Confirmation" },
          { label: "Limit at zone (no confirmation)", value: "limit", next: "slMethod", branchLabel: "Entry: Limit" }
        ]
      },

      slMethod: {
        id: "slMethod",
        type: "risk",
        text: "How are you placing your stop loss?",
        note: "Best: beyond the liquidity that got swept. Worst: inside the wick that got hunted.",
        field: "slMethod",
        options: [
          { label: "Beyond swept liquidity", value: "beyond_sweep", next: "tpMethod", branchLabel: "SL: Beyond sweep" },
          { label: "Just under/over OB", value: "under_ob", next: "infoTightSl", branchLabel: "SL: Under/over OB only" }
        ]
      },

      infoTightSl: {
        id: "infoTightSl",
        type: "info",
        text: "You are putting SL just under/over the OB.",
        note: "This often gets wicked. In SMC, the safer stop is beyond the liquidity that was actually taken.",
        options: [
          { label: "Iâ€™ll move SL beyond liquidity", next: "slMethodAdjusted", branchLabel: "Adjust SL" },
          { label: "I insist on tight SL", next: "tpMethod", branchLabel: "Accept tight SL risk" }
        ]
      },

      slMethodAdjusted: {
        id: "slMethodAdjusted",
        type: "risk",
        text: "SL will be moved beyond the swept liquidity.",
        note: "RR might be smaller, but survivability is higher.",
        field: "slMethod",
        options: [
          { label: "Confirm SL beyond liquidity", value: "beyond_sweep", next: "tpMethod", branchLabel: "SL: Adjusted beyond sweep" }
        ]
      },

      tpMethod: {
        id: "tpMethod",
        type: "risk",
        text: "How are you planning to take profit?",
        note: "Structure-based exits beat emotional exits.",
        field: "tpMethod",
        options: [
          { label: "TP1 FVG fill, TP2 next liquidity", value: "fvg_liquidity", next: "endReady", branchLabel: "TP: FVG + Liquidity" },
          { label: "Single TP at major liquidity", value: "single_liquidity", next: "endReady", branchLabel: "TP: Single liquidity" },
          { label: "No clear plan yet", value: "no_plan", next: "infoNoTpPlan", branchLabel: "TP: No plan" }
        ]
      },

      infoNoTpPlan: {
        id: "infoNoTpPlan",
        type: "info",
        text: "You donâ€™t have a clear TP plan.",
        note: "Youâ€™re about to trade without an exit idea. Either define a plan now or donâ€™t take this trade.",
        options: [
          { label: "Fine, Iâ€™ll plan TP as FVG + liquidity", next: "tpMethodForced", branchLabel: "Force TP plan" },
          { label: "I accept that this is low quality", next: "endReady", branchLabel: "Proceed without strong TP plan" }
        ]
      },

      tpMethodForced: {
        id: "tpMethodForced",
        type: "risk",
        text: "TP1 at nearest FVG fill, TP2 at next clear liquidity pool.",
        note: "This is the default smart plan: partial out at rebalancing, then at main target.",
        field: "tpMethod",
        options: [
          { label: "Confirm this TP plan", value: "fvg_liquidity", next: "endReady", branchLabel: "TP: Forced FVG + Liquidity" }
        ]
      },

      endReady: {
        id: "endReady",
        type: "end",
        text: "This setup is now defined. You can store it in your journal and execute according to this plan.",
        note: "You still have to obey it in real time. But the logic is now structured instead of emotional.",
        options: [
          { label: "Review summary & Save trade", next: "saveStep", branchLabel: "Go to Save" }
        ]
      },

      saveStep: {
        id: "saveStep",
        type: "end",
        text: "If youâ€™re satisfied with this plan, click â€œSave Trade to Journalâ€.",
        note: "When logged in, it saves to Firestore. When logged out, it saves locally.",
        options: [
          { label: "Back to previous step", next: "endReady", branchLabel: "Back before save" }
        ]
      }
    };

    let currentNodeId = "start";
    let path = [];
    let currentTrade = { marketType: "crypto" };

    function humanReadableType(type) {
      if (type === "context") return "Phase 0: Context";
      if (type === "htf") return "Phase 1: HTF Bias";
      if (type === "zone") return "Phase 2: Zone Selection";
      if (type === "entry") return "Phase 3: Entry Model";
      if (type === "risk") return "Phase 4: Risk & TP";
      if (type === "end") return "Phase 5: Finalization";
      return "Info / Reminder";
    }

    function updateBiasLabel() {
      const bias = currentTrade.htfBias;
      if (!bias) {
        biasLabelEl.textContent = "Bias: â€“";
        biasLabelEl.style.borderColor = "rgba(148,163,184,0.6)";
      } else if (bias === "bullish") {
        biasLabelEl.textContent = "Bias: Bullish";
        biasLabelEl.style.borderColor = "rgba(34,197,94,0.9)";
      } else if (bias === "bearish") {
        biasLabelEl.textContent = "Bias: Bearish";
        biasLabelEl.style.borderColor = "rgba(239,68,68,0.9)";
      } else {
        biasLabelEl.textContent = "Bias: " + bias;
      }
    }

    function updateSummary() {
      summaryPairEl.textContent = "Pair: " + (currentTrade.pair || "â€“");
      summarySessionEl.textContent = "Session: " + (currentTrade.session || "â€“");
      summaryBiasEl.textContent = "HTF Bias: " + (currentTrade.htfBias || "â€“");
      summaryDisplacementEl.textContent = "Displacement: " + (currentTrade.displacementType || "â€“");
      summaryZoneEl.textContent = "Zone Type: " + (currentTrade.zoneType || "â€“");
      summaryEntryEl.textContent = "Entry Type: " + (currentTrade.entryType || "â€“");
      summarySlEl.textContent = "SL Method: " + (currentTrade.slMethod || "â€“");
      summaryTpEl.textContent = "TP Method: " + (currentTrade.tpMethod || "â€“");
      summaryTfEl.textContent = "Entry TF: " + (currentTrade.entryTf || "â€“");
      summaryTagEl.textContent = "Tag: " + (currentTrade.setupTag || "â€“");
      summaryScoreEl.textContent = "Setup Score: " + (
        currentTrade.setupScore != null ? currentTrade.setupScore + "/10" : "â€“"
      );
    }

    function syncMetaUIFromTrade() {
      metaTfButtons.forEach(btn => {
        const tf = btn.getAttribute("data-tf");
        if (currentTrade.entryTf === tf) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });

      metaTagSelectEl.value = currentTrade.setupTag || "";
      metaNotesEl.value = currentTrade.notes || "";
    }

    function renderCurrentNode() {
      const node = nodes[currentNodeId];
      if (!node) {
        alert("Internal error: node '" + currentNodeId + "' not found.");
        return;
      }

      nodeTextEl.textContent = node.text;
      nodeNoteEl.textContent = node.note || "";
      nodeTypeLabelEl.textContent = humanReadableType(node.type);
      updateBiasLabel();
      updateSummary();
      syncMetaUIFromTrade();

      if (node.type === "context") {
        statusLineTextEl.textContent = "Context: define pair and session first.";
      } else if (node.type === "htf") {
        statusLineTextEl.textContent = "HTF phase: structure + displacement. No LTF noise yet.";
      } else if (node.type === "zone") {
        statusLineTextEl.textContent = "Zone phase: Reversal vs Continuation.";
      } else if (node.type === "entry") {
        statusLineTextEl.textContent = "Entry phase: confirmation vs limit.";
      } else if (node.type === "risk") {
        statusLineTextEl.textContent = "Risk phase: SL and TP rules.";
      } else if (node.type === "end") {
        statusLineTextEl.textContent = "Finalize and save or adjust.";
      } else {
        statusLineTextEl.textContent = "Info step. Read it fully.";
      }

      optionsContainerEl.innerHTML = "";
      node.options.forEach((opt, i) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn " + (i === 0 ? "btn-primary" : "btn-outline");
        btn.textContent = opt.label;
        btn.onclick = () => handleOptionClick(node, opt);
        optionsContainerEl.appendChild(btn);
      });

      saveContainerEl.innerHTML = "";
      if (node.id === "saveStep") {
        const saveBtn = document.createElement("button");
        saveBtn.type = "button";
        saveBtn.className = "btn btn-primary";
        saveBtn.textContent = "ðŸ’¾ Save Trade to Journal";
        saveBtn.onclick = saveCurrentTrade;
        saveContainerEl.appendChild(saveBtn);
      }

      backBtnEl.disabled = path.length === 0;
      backBtnEl.style.opacity = backBtnEl.disabled ? 0.4 : 1;
    }

    function handleOptionClick(node, option) {
      path.push({
        nodeId: node.id,
        text: node.text,
        branchLabel: option.branchLabel || option.label
      });

      if (node.field) {
        currentTrade[node.field] = option.value || option.label;
      }
      if (node.field === "htfBias") {
        currentTrade.htfBias = option.value;
      }

      currentNodeId = option.next;
      renderCurrentNode();
    }

    function restartWizard() {
      path = [];
      currentTrade = { marketType: "crypto" };
      currentNodeId = "start";
      renderCurrentNode();
    }

    function goBack() {
      if (path.length === 0) return;

      path.pop();
      currentTrade = { marketType: "crypto" };
      currentNodeId = "start";

      for (let i = 0; i < path.length; i++) {
        const step = path[i];
        const node = nodes[currentNodeId];
        if (!node) break;

        let chosenOption = null;
        for (let j = 0; j < node.options.length; j++) {
          const opt = node.options[j];
          if (opt.branchLabel === step.branchLabel) {
            chosenOption = opt;
            break;
          }
        }
        if (!chosenOption) break;

        if (node.field) {
          currentTrade[node.field] = chosenOption.value || chosenOption.label;
        }
        if (node.field === "htfBias") {
          currentTrade.htfBias = chosenOption.value;
        }

        currentNodeId = chosenOption.next;
      }

      renderCurrentNode();
    }

    backBtnEl.onclick = goBack;
    restartBtnEl.onclick = restartWizard;

    metaTfButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const tf = btn.getAttribute("data-tf");
        currentTrade.entryTf = tf;
        syncMetaUIFromTrade();
        updateSummary();
      });
    });

    metaTagSelectEl.addEventListener("change", () => {
      currentTrade.setupTag = metaTagSelectEl.value || null;
      updateSummary();
    });

    metaNotesEl.addEventListener("input", () => {
      currentTrade.notes = metaNotesEl.value || "";
    });

    function calculateSetupScore(trade) {
      let score = 0;
      if (trade.htfSweep === "yes") score += 2;
      if (trade.displacementType === "impulse") score += 2;
      else if (trade.displacementType === "staircase") score += 1;
      if (trade.htfBias === "bullish" && trade.htfArea === "discount") score += 2;
      if (trade.htfBias === "bearish" && trade.htfArea === "premium") score += 2;
      if (trade.zoneType === "reversal" || trade.zoneType === "continuation") score += 1;
      if (trade.entryType === "confirmation") score += 2;
      else if (trade.entryType === "limit") score += 1;
      if (trade.slMethod === "beyond_sweep") score += 1;
      if (trade.tpMethod === "fvg_liquidity" || trade.tpMethod === "single_liquidity") score += 1;
      if (score < 0) score = 0;
      if (score > 10) score = 10;
      return score;
    }

    function loadTradesLocal() {
      try {
        const raw = localStorage.getItem("trades");
        if (!raw) return [];
        return JSON.parse(raw) || [];
      } catch {
        return [];
      }
    }

    function saveTradesLocal(allTrades) {
      try {
        localStorage.setItem("trades", JSON.stringify(allTrades));
      } catch {}
    }

    function clearLocalTrades() {
      localStorage.removeItem("trades");
    }

    async function loadTradesFirestore() {
      if (!currentUser) return [];
      const q = query(
        collection(db, "trades"),
        where("userId", "==", currentUser.uid),
        orderBy("createdAt", "desc")
      );
      const snap = await getDocs(q);
      const arr = [];
      snap.forEach(docSnap => {
        arr.push({ docId: docSnap.id, ...docSnap.data() });
      });
      tradesCache = arr;
      return arr;
    }

    async function saveTradeFirestore(trade) {
      if (!currentUser) return;
      await addDoc(collection(db, "trades"), {
        userId: currentUser.uid,
        ...trade
      });
    }

    async function updateTradeFirestore(docId, partial) {
      if (!currentUser || !docId) return;
      const ref = doc(db, "trades", docId);
      await updateDoc(ref, partial);
    }

    function updateStats(trades) {
      const total = trades.length;
      statsTotalEl.textContent = "Trades: " + total;

      if (!total) {
        statsWinrateEl.textContent = "Winrate: â€“";
        statsAvgREl.textContent = "Avg R: â€“";
        return;
      }

      let wins = 0;
      let losses = 0;
      let sumR = 0;
      let rCount = 0;

      for (const t of trades) {
        if (t.result === "win") wins++;
        else if (t.result === "loss") losses++;
        if (t.rrAchieved != null && !isNaN(t.rrAchieved)) {
          sumR += Number(t.rrAchieved);
          rCount++;
        }
      }

      const denom = wins + losses;
      if (denom === 0) {
        statsWinrateEl.textContent = "Winrate: â€“";
      } else {
        const wr = (wins / denom) * 100;
        statsWinrateEl.textContent = "Winrate: " + wr.toFixed(1) + "%";
      }

      if (rCount === 0) {
        statsAvgREl.textContent = "Avg R: â€“";
      } else {
        const avgR = sumR / rCount;
        statsAvgREl.textContent = "Avg R: " + avgR.toFixed(2);
      }
    }

    function applyFilters(trades) {
      const s = filterSessionEl.value;
      const z = filterZoneEl.value;
      const e = filterEntryEl.value;
      const r = filterResultEl.value;

      return trades.filter(t => {
        if (s && t.session !== s) return false;
        if (z && t.zoneType !== z) return false;
        if (e && t.entryType !== e) return false;
        if (r && t.result !== r) return false;
        return true;
      });
    }

    function renderJournalTable(trades) {
      journalBodyEl.innerHTML = "";
      updateStats(trades);

      if (!trades.length) {
        journalEmptyEl.style.display = "block";
        return;
      }
      journalEmptyEl.style.display = "none";

      trades.forEach(t => {
        const tr = document.createElement("tr");
        const idx = lastLoadedTrades.indexOf(t);

        const dateTd = document.createElement("td");
        dateTd.textContent = t.createdAt ? t.createdAt.split("T")[0] : "-";
        tr.appendChild(dateTd);

        const pairTd = document.createElement("td");
        pairTd.textContent = t.pair || "-";
        tr.appendChild(pairTd);

        const tfTd = document.createElement("td");
        tfTd.textContent = t.entryTf || "-";
        tr.appendChild(tfTd);

        const biasTd = document.createElement("td");
        biasTd.textContent = t.htfBias || "-";
        tr.appendChild(biasTd);

        const zoneTd = document.createElement("td");
        zoneTd.textContent = t.zoneType || "-";
        tr.appendChild(zoneTd);

        const entryTd = document.createElement("td");
        entryTd.textContent = t.entryType || "-";
        tr.appendChild(entryTd);

        const tagTd = document.createElement("td");
        tagTd.textContent = t.setupTag || "-";
        tr.appendChild(tagTd);

        const scoreTd = document.createElement("td");
        scoreTd.textContent = t.setupScore != null ? t.setupScore + "/10" : "-";
        tr.appendChild(scoreTd);

        const resultTd = document.createElement("td");
        const pill = document.createElement("span");
        const res = t.result || "";
        if (res === "win") {
          pill.className = "pill pill-win";
          pill.textContent = "WIN";
        } else if (res === "loss") {
          pill.className = "pill pill-loss";
          pill.textContent = "LOSS";
        } else if (res === "be") {
          pill.className = "pill pill-be";
          pill.textContent = "B/E";
        } else {
          pill.textContent = "-";
        }
        resultTd.appendChild(pill);
        tr.appendChild(resultTd);

        const rrTd = document.createElement("td");
        rrTd.textContent = t.rrAchieved != null ? t.rrAchieved : "-";
        tr.appendChild(rrTd);

        const actionsTd = document.createElement("td");
        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "btn btn-ghost";
        editBtn.textContent = "Edit";
        editBtn.onclick = () => editTrade(idx);
        actionsTd.appendChild(editBtn);
        tr.appendChild(actionsTd);

        journalBodyEl.appendChild(tr);
      });
    }

    function updateChartsAndInsights(trades) {
      const sessions = ["London", "New York", "Asia", "Off-hours"];
      const sessionWinrates = [];
      const sessionCounts = [];

      sessions.forEach(s => {
        const subset = trades.filter(t => t.session === s);
        const total = subset.length;
        sessionCounts.push(total);
        if (!total) {
          sessionWinrates.push(0);
        } else {
          let wins = 0;
          let losses = 0;
          subset.forEach(t => {
            if (t.result === "win") wins++;
            else if (t.result === "loss") losses++;
          });
          const denom = wins + losses;
          const wr = denom ? (wins / denom) * 100 : 0;
          sessionWinrates.push(wr);
        }
      });

      const sessionData = {
        labels: sessions,
        datasets: [{ label: "Winrate %", data: sessionWinrates }]
      };

      if (!sessionChart) {
        sessionChart = new Chart(sessionChartCtx, {
          type: "bar",
          data: sessionData,
          options: {
            responsive: true,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.parsed.y.toFixed(1)}% (n=${sessionCounts[ctx.dataIndex]})`
                }
              }
            },
            scales: { y: { beginAtZero: true, max: 100 } }
          }
        });
      } else {
        sessionChart.data = sessionData;
        sessionChart.update();
      }

      const buckets = ["0â€“4", "5â€“7", "8â€“10"];
      const bucketRanges = [
        { min: 0, max: 4 },
        { min: 5, max: 7 },
        { min: 8, max: 10 }
      ];

      const bucketWinrate = [];
      const bucketCounts = [];

      bucketRanges.forEach(rng => {
        const subset = trades.filter(t => {
          if (t.setupScore == null) return false;
          const s = Number(t.setupScore);
          return s >= rng.min && s <= rng.max;
        });
        const total = subset.length;
        bucketCounts.push(total);
        if (!total) {
          bucketWinrate.push(0);
        } else {
          let wins = 0;
          let losses = 0;
          subset.forEach(t => {
            if (t.result === "win") wins++;
            else if (t.result === "loss") losses++;
          });
          const denom = wins + losses;
          const wr = denom ? (wins / denom) * 100 : 0;
          bucketWinrate.push(wr);
        }
      });

      const scoreData = {
        labels: buckets,
        datasets: [{ label: "Winrate %", data: bucketWinrate }]
      };

      if (!scoreChart) {
        scoreChart = new Chart(scoreChartCtx, {
          type: "bar",
          data: scoreData,
          options: {
            responsive: true,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.parsed.y.toFixed(1)}% (n=${bucketCounts[ctx.dataIndex]})`
                }
              }
            },
            scales: { y: { beginAtZero: true, max: 100 } }
          }
        });
      } else {
        scoreChart.data = scoreData;
        scoreChart.update();
      }

      const rLabels = ["< -1R", "-1R to 0", "0 to 1R", "1R to 2R", "> 2R"];
      const rCounts = [0, 0, 0, 0, 0];

      trades.forEach(t => {
        if (t.rrAchieved == null || isNaN(t.rrAchieved)) return;
        const r = Number(t.rrAchieved);
        if (r < -1) rCounts[0]++;
        else if (r < 0) rCounts[1]++;
        else if (r < 1) rCounts[2]++;
        else if (r < 2) rCounts[3]++;
        else rCounts[4]++;
      });

      const rData = {
        labels: rLabels,
        datasets: [{ label: "Count", data: rCounts }]
      };

      if (!rDistChart) {
        rDistChart = new Chart(rDistChartCtx, {
          type: "bar",
          data: rData,
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true } }
          }
        });
      } else {
        rDistChart.data = rData;
        rDistChart.update();
      }

      if (!trades.length) {
        insightsContentEl.textContent = "Not enough data yet. Log more trades.";
        return;
      }

      const comboMap = new Map();
      trades.forEach(t => {
        const key = `${t.session || "?"} | ${t.zoneType || "?"} | ${t.entryType || "?"}`;
        if (!comboMap.has(key)) {
          comboMap.set(key, {
            key,
            count: 0,
            wins: 0,
            losses: 0,
            sumR: 0,
            rCount: 0
          });
        }
        const g = comboMap.get(key);
        g.count++;
        if (t.result === "win") g.wins++;
        else if (t.result === "loss") g.losses++;
        if (t.rrAchieved != null && !isNaN(t.rrAchieved)) {
          g.sumR += Number(t.rrAchieved);
          g.rCount++;
        }
      });

      const combos = Array.from(comboMap.values()).filter(g => g.count >= 3);
      combos.forEach(g => {
        const denom = g.wins + g.losses;
        g.winrate = denom ? (g.wins / denom) * 100 : 0;
        g.avgR = g.rCount ? (g.sumR / g.rCount) : 0;
      });

      combos.sort((a, b) => b.avgR - a.avgR);
      const best = combos[0];
      const worst = combos[combos.length - 1];

      const tfMap = new Map();
      trades.forEach(t => {
        const tf = t.entryTf || "unknown";
        if (!tfMap.has(tf)) {
          tfMap.set(tf, { tf, count: 0, sumR: 0, rCount: 0 });
        }
        const g = tfMap.get(tf);
        g.count++;
        if (t.rrAchieved != null && !isNaN(t.rrAchieved)) {
          g.sumR += Number(t.rrAchieved);
          g.rCount++;
        }
      });

      const tfStats = Array.from(tfMap.values()).filter(g => g.count >= 3);
      tfStats.forEach(g => {
        g.avgR = g.rCount ? (g.sumR / g.rCount) : 0;
      });
      tfStats.sort((a, b) => b.avgR - a.avgR);
      const bestTf = tfStats[0];
      const worstTf = tfStats[tfStats.length - 1];

      let html = "";

      if (best) {
        html += `<div><strong>Best combo</strong>: ${best.key} &mdash; avg R â‰ˆ ${best.avgR.toFixed(2)} (n=${best.count}, WRâ‰ˆ${best.winrate.toFixed(1)}%).</div>`;
      }
      if (worst && worst !== best) {
        html += `<div><strong>Worst combo</strong>: ${worst.key} &mdash; avg R â‰ˆ ${worst.avgR.toFixed(2)} (n=${worst.count}, WRâ‰ˆ${worst.winrate.toFixed(1)}%).</div>`;
      }

      if (bestTf) {
        html += `<div style="margin-top:4px;"><strong>Best entry TF</strong>: ${bestTf.tf} &mdash; avg R â‰ˆ ${bestTf.avgR.toFixed(2)} (n=${bestTf.count}).</div>`;
      }
      if (worstTf && worstTf !== bestTf) {
        html += `<div><strong>Worst entry TF</strong>: ${worstTf.tf} &mdash; avg R â‰ˆ ${worstTf.avgR.toFixed(2)} (n=${worstTf.count}).</div>`;
      }

      if (!html) {
        html = "Need more samples in each combo (min 3 trades) before I start bullying your patterns.";
      }

      insightsContentEl.innerHTML = html;
    }

    async function renderJournal() {
      let trades;
      if (currentUser) {
        trades = await loadTradesFirestore();
      } else {
        trades = loadTradesLocal();
      }
      lastLoadedTrades = trades;
      const filtered = applyFilters(trades);
      renderJournalTable(filtered);
      updateChartsAndInsights(filtered);
    }

    async function saveCurrentTrade() {
      const todayKey = getTodayKey();
      if (!currentDailyContext || currentDailyContext.date !== todayKey) {
        ensureTodayContext();
      }

      if (!hasAnyDailyContext(currentDailyContext)) {
        alert("Set today's market context before saving trades.");
        return;
      }

      const trade = JSON.parse(JSON.stringify(currentTrade));
      trade.marketType = "crypto";
      trade.createdAt = new Date().toISOString();
      trade.result = null;
      trade.rrAchieved = null;
      trade.setupScore = calculateSetupScore(trade);

      trade.contextDate          = todayKey;
      trade.ctx_btcHTFTrend      = currentDailyContext.btcHTFTrend || null;
      trade.ctx_btcLTFState      = currentDailyContext.btcLTFState || null;
      trade.ctx_regime           = currentDailyContext.regime || null;
      trade.ctx_fearGreedBucket  = currentDailyContext.fearGreedBucket || null;
      trade.ctx_volatility       = currentDailyContext.volatility || null;
      trade.ctx_btcDominanceTrend= currentDailyContext.btcDominanceTrend || null;
      trade.ctx_newsImpact       = currentDailyContext.newsImpact || null;

      if (currentUser) {
        await saveTradeFirestore(trade);
      } else {
        const allTrades = loadTradesLocal();
        allTrades.push(trade);
        saveTradesLocal(allTrades);
      }

      await renderJournal();
      alert("Trade saved with score " + trade.setupScore + "/10.");
      restartWizard();
    }

    async function editTrade(index) {
      let trades;
      if (currentUser) {
        trades = tradesCache;
      } else {
        trades = loadTradesLocal();
      }
      if (!trades || index < 0 || index >= trades.length) return;
      const t = trades[index];

      let result = prompt("Result? (win/loss/be)", t.result || "");
      if (result !== null) {
        result = result.toLowerCase().trim();
        if (result && !["win", "loss", "be"].includes(result)) {
          alert("Invalid result. Use win, loss, or be.");
          return;
        }
        t.result = result || null;
      }

      const rrStr = prompt("R multiple achieved? (e.g. 1.5, -0.5)", t.rrAchieved != null ? t.rrAchieved : "");
      if (rrStr !== null && rrStr.trim() !== "") {
        const rr = parseFloat(rrStr);
        if (!isNaN(rr)) {
          t.rrAchieved = rr;
        }
      }

      if (currentUser) {
        tradesCache[index] = t;
        await updateTradeFirestore(t.docId, {
          result: t.result || null,
          rrAchieved: t.rrAchieved != null ? t.rrAchieved : null
        });
      } else {
        const allTrades = loadTradesLocal();
        allTrades[index] = t;
        saveTradesLocal(allTrades);
      }

      await renderJournal();
    }

    clearBtnEl.onclick = () => {
      if (!currentUser) {
        if (confirm("Clear ALL saved trades from local storage on this device?")) {
          clearLocalTrades();
          renderJournal();
        }
      } else {
        alert("Clear All is only for local mode. For Firestore, delete trades manually later.");
      }
    };

    [filterSessionEl, filterZoneEl, filterEntryEl, filterResultEl].forEach(sel => {
      sel.addEventListener("change", () => {
        const filtered = applyFilters(lastLoadedTrades);
        renderJournalTable(filtered);
        updateChartsAndInsights(filtered);
      });
    });

    function updateAuthUI() {
      if (currentUser) {
        authStatusEl.textContent = "Logged in as " + (currentUser.email || currentUser.uid);
        loginBtnEl.disabled = true;
        registerBtnEl.disabled = true;
        logoutBtnEl.disabled = false;
        authEmailEl.disabled = true;
        authPasswordEl.disabled = true;
      } else {
        authStatusEl.textContent = "Not logged in (local mode)";
        loginBtnEl.disabled = false;
        registerBtnEl.disabled = false;
        logoutBtnEl.disabled = true;
        authEmailEl.disabled = false;
        authPasswordEl.disabled = false;
      }
    }

    loginBtnEl.onclick = async () => {
      const email = authEmailEl.value.trim();
      const pwd = authPasswordEl.value.trim();
      if (!email || !pwd) {
        alert("Enter email and password.");
        return;
      }
      try {
        await signInWithEmailAndPassword(auth, email, pwd);
      } catch (e) {
        alert("Login error: " + e.message);
      }
    };

    registerBtnEl.onclick = async () => {
      const email = authEmailEl.value.trim();
      const pwd = authPasswordEl.value.trim();
      if (!email || !pwd) {
        alert("Enter email and password.");
        return;
      }
      try {
        await createUserWithEmailAndPassword(auth, email, pwd);
        alert("Registered. You are now logged in.");
      } catch (e) {
        alert("Register error: " + e.message);
      }
    };

    logoutBtnEl.onclick = async () => {
      try {
        await signOut(auth);
      } catch (e) {
        alert("Logout error: " + e.message);
      }
    };

    onAuthStateChanged(auth, async (user) => {
      currentUser = user || null;
      updateAuthUI();
      await renderJournal();
    });

    // Init: daily context + wizard + journal
    loadDailyContextLocal();
    ensureTodayContext();
    updateDailyContextUI();

    restartWizard();
    renderJournal();
  </script>
</body>
</html>
