<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SMC Crypto Trading OS (Cloud v1)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --bg: #020617;
      --card-bg: #020617;
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.16);
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1e293b 0, #020617 40%, #020617 100%);
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.3fr);
      gap: 24px;
    }
    @media (max-width: 900px) {
      .app { grid-template-columns: minmax(0,1fr); }
    }

    .card {
      background: linear-gradient(145deg, #020617 0%, #020617 50%, #020617 100%);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 20px 20px 16px;
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(79, 70, 229, 0.18), transparent 60%);
      pointer-events: none;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 14px;
      position: relative;
      z-index: 1;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .card-subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      white-space: nowrap;
    }

    .prompt {
      position: relative;
      z-index: 1;
      margin-bottom: 16px;
      padding: 14px 14px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .prompt-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent);
      margin-bottom: 6px;
    }

    .prompt-text {
      font-size: 0.98rem;
      line-height: 1.5;
    }

    .note {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .options {
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 12px;
    }

    .btn {
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.85rem;
      border: 1px solid transparent;
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.14s ease-out;
    }
    .btn-primary {
      background: radial-gradient(circle at top left, #4f46e5, #4338ca);
      border-color: rgba(129, 140, 248, 0.9);
      box-shadow: 0 0 0 1px rgba(129, 140, 248, 0.2);
    }
    .btn-outline {
      border-color: rgba(148, 163, 184, 0.6);
    }
    .btn-ghost {
      border-color: transparent;
      background: transparent;
      color: var(--text-muted);
      padding-inline: 0;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.7);
      opacity: 0.97;
    }
    .btn:active {
      transform: translateY(0);
      box-shadow: none;
      opacity: 0.9;
    }

    .status-line {
      font-size: 0.8rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-top: 6px;
      position: relative;
      z-index: 1;
    }

    .flow {
      position: relative;
      z-index: 1;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(148, 163, 184, 0.4);
      font-size: 0.8rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .summary {
      position: relative;
      z-index: 1;
      margin-top: 10px;
      padding: 10px 12px 8px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px dashed rgba(148, 163, 184, 0.5);
      font-size: 0.8rem;
    }

    .summary-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .summary-item {
      margin-bottom: 2px;
    }

    /* Auth bar */

    .auth-bar {
      position: relative;
      z-index: 1;
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 0.78rem;
    }

    .auth-input {
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: #e5e7eb;
      font-size: 0.78rem;
      min-width: 130px;
    }

    .auth-status {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    /* Journal */

    .journal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }

    .stats {
      display: flex;
      flex-direction: column;
      gap: 3px;
      font-size: 0.78rem;
      text-align: right;
      color: var(--text-muted);
    }

    .stats span {
      display: block;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
      position: relative;
      z-index: 1;
    }

    th, td {
      padding: 6px 6px;
      text-align: left;
      border-bottom: 1px solid rgba(30, 41, 59, 0.85);
    }

    th {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    tbody tr:hover {
      background-color: rgba(15, 23, 42, 0.8);
    }

    .pill {
      display: inline-block;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .pill-win { background: rgba(34,197,94,0.16); color: #bbf7d0; }
    .pill-loss { background: rgba(239,68,68,0.16); color: #fecaca; }
    .pill-be { background: rgba(148,163,184,0.16); color: #e5e7eb; }

    .empty-state {
      font-size: 0.8rem;
      color: var(--text-muted);
      padding-top: 6px;
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- LEFT: WIZARD -->
    <div class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Crypto SMC Wizard</div>
          <div class="card-subtitle" id="node-type-label">Phase: â€“</div>
        </div>
        <div class="badge" id="bias-label">Bias: â€“</div>
      </div>

      <div class="prompt">
        <div class="prompt-label">Current Step</div>
        <div class="prompt-text" id="node-text">Loadingâ€¦</div>
        <div class="note" id="node-note"></div>
      </div>

      <div class="options" id="options-container"></div>

      <div class="status-line">
        <span id="status-line-text">Follow the steps. No skipping.</span>
        <div>
          <button class="btn btn-ghost" id="back-btn" type="button">âŸµ Back</button>
          <button class="btn btn-ghost" id="restart-btn" type="button">âŸ³ Restart</button>
        </div>
      </div>

      <div class="flow">
        <strong>Flow:</strong> Context â†’ HTF Bias â†’ Zone â†’ Entry â†’ Risk â†’ Save trade.  
        This version is crypto-only; Firestore sync is enabled when logged in.
      </div>

      <div class="summary" id="summary-panel">
        <div class="summary-title">Current Trade Plan (Draft)</div>
        <div class="summary-item" id="summary-pair">Pair: â€“</div>
        <div class="summary-item" id="summary-session">Session: â€“</div>
        <div class="summary-item" id="summary-bias">HTF Bias: â€“</div>
        <div class="summary-item" id="summary-displacement">Displacement: â€“</div>
        <div class="summary-item" id="summary-zone">Zone Type: â€“</div>
        <div class="summary-item" id="summary-entry">Entry Type: â€“</div>
        <div class="summary-item" id="summary-sl">SL Method: â€“</div>
        <div class="summary-item" id="summary-tp">TP Method: â€“</div>
        <div class="summary-item" id="summary-score">Setup Score: â€“</div>
      </div>

      <div class="options" id="save-container" style="margin-top: 10px;"></div>
    </div>

    <!-- RIGHT: AUTH + JOURNAL -->
    <div class="card">
      <!-- Auth bar -->
      <div class="auth-bar">
        <input class="auth-input" id="auth-email" type="email" placeholder="Email" />
        <input class="auth-input" id="auth-password" type="password" placeholder="Password" />
        <button class="btn btn-outline" id="login-btn" type="button">Login</button>
        <button class="btn btn-outline" id="register-btn" type="button">Register</button>
        <button class="btn btn-ghost" id="logout-btn" type="button">Logout</button>
        <span class="auth-status" id="auth-status">Not logged in (local mode)</span>
      </div>

      <div class="journal-header">
        <div>
          <div class="card-title">Journal</div>
          <div class="card-subtitle">Local when logged out. Cloud when logged in.</div>
        </div>
        <div class="stats">
          <span id="stats-total">Trades: 0</span>
          <span id="stats-winrate">Winrate: â€“</span>
          <span id="stats-avgR">Avg R: â€“</span>
        </div>
      </div>

      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Pair</th>
            <th>Bias</th>
            <th>Zone</th>
            <th>Entry</th>
            <th>Score</th>
            <th>Result</th>
            <th>R</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="journal-body"></tbody>
      </table>
      <div class="empty-state" id="journal-empty">No trades yet. Finish a wizard run and save.</div>

      <div style="margin-top: 8px; text-align: right; position: relative; z-index:1;">
        <button class="btn btn-outline" id="clear-btn" type="button">Clear All (local only)</button>
      </div>
    </div>
  </div>

  <script type="module">
    // ===== Firebase Imports =====
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged,
      createUserWithEmailAndPassword,
      signInWithEmailAndPassword,
      signOut
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
    import {
      getFirestore,
      collection,
      addDoc,
      getDocs,
      query,
      where,
      orderBy,
      doc,
      updateDoc
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

    // ðŸ” REPLACE THIS with your actual const firebaseConfig = {
  apiKey: "AIzaSyAlKjwX_G0tJptXdysDpQ4UB-y2MPFuq04",
  authDomain: "smc-trade-os.firebaseapp.com",
  projectId: "smc-trade-os",
  storageBucket: "smc-trade-os.firebasestorage.app",
  messagingSenderId: "565962124502",
  appId: "1:565962124502:web:891e9d125fd49f23052d77",
  measurementId: "G-LGTW0D5ZKQ" // this extra field is fine, or you can delete it
};
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUser = null;
    let tradesCache = []; // used when logged in (Firestore)

    // ===== DOM elements =====
    const authEmailEl = document.getElementById("auth-email");
    const authPasswordEl = document.getElementById("auth-password");
    const loginBtnEl = document.getElementById("login-btn");
    const registerBtnEl = document.getElementById("register-btn");
    const logoutBtnEl = document.getElementById("logout-btn");
    const authStatusEl = document.getElementById("auth-status");

    const nodeTypeLabelEl = document.getElementById("node-type-label");
    const biasLabelEl = document.getElementById("bias-label");
    const nodeTextEl = document.getElementById("node-text");
    const nodeNoteEl = document.getElementById("node-note");
    const optionsContainerEl = document.getElementById("options-container");
    const saveContainerEl = document.getElementById("save-container");
    const statusLineTextEl = document.getElementById("status-line-text");
    const backBtnEl = document.getElementById("back-btn");
    const restartBtnEl = document.getElementById("restart-btn");

    const summaryPairEl = document.getElementById("summary-pair");
    const summarySessionEl = document.getElementById("summary-session");
    const summaryBiasEl = document.getElementById("summary-bias");
    const summaryDisplacementEl = document.getElementById("summary-displacement");
    const summaryZoneEl = document.getElementById("summary-zone");
    const summaryEntryEl = document.getElementById("summary-entry");
    const summarySlEl = document.getElementById("summary-sl");
    const summaryTpEl = document.getElementById("summary-tp");
    const summaryScoreEl = document.getElementById("summary-score");

    const journalBodyEl = document.getElementById("journal-body");
    const journalEmptyEl = document.getElementById("journal-empty");
    const clearBtnEl = document.getElementById("clear-btn");

    const statsTotalEl = document.getElementById("stats-total");
    const statsWinrateEl = document.getElementById("stats-winrate");
    const statsAvgREl = document.getElementById("stats-avgR");

    // ===== Wizard nodes (same logic as before) =====
    const nodes = {
      start: {
        id: "start",
        type: "context",
        text: "What pair are you planning to trade?",
        note: "You can add more pairs later. For now, pick the closest match.",
        field: "pair",
        options: [
          { label: "BTCUSDT", value: "BTCUSDT", next: "session", branchLabel: "Pair: BTCUSDT" },
          { label: "ETHUSDT", value: "ETHUSDT", next: "session", branchLabel: "Pair: ETHUSDT" },
          { label: "Altcoin / Other", value: "ALT", next: "session", branchLabel: "Pair: ALT/OTHER" }
        ]
      },

      session: {
        id: "session",
        type: "context",
        text: "What session are you mainly trading this setup in?",
        note: "This will matter later when you analyze performance by session.",
        field: "session",
        options: [
          { label: "London", value: "London", next: "htfSweep", branchLabel: "Session: London" },
          { label: "New York", value: "New York", next: "htfSweep", branchLabel: "Session: New York" },
          { label: "Asia", value: "Asia", next: "htfSweep", branchLabel: "Session: Asia" },
          { label: "Weekend / Random", value: "Off-hours", next: "htfSweep", branchLabel: "Session: Off-hours" }
        ]
      },

      htfSweep: {
        id: "htfSweep",
        type: "htf",
        text: "On HTF (1H/4H), did price sweep a clear liquidity pool (equal highs/lows or a clear prior swing)?",
        note: "If not, youâ€™re early. Usually better to wait for liquidity to be taken first.",
        field: "htfSweep",
        options: [
          { label: "Yes, clear sweep", value: "yes", next: "displacementType", branchLabel: "HTF Sweep: YES" },
          { label: "No, nothing obvious", value: "no", next: "infoNoSweep", branchLabel: "HTF Sweep: NO" }
        ]
      },

      infoNoSweep: {
        id: "infoNoSweep",
        type: "info",
        text: "No clear HTF sweep = low-quality context.",
        note: "Youâ€™re probably the liquidity if you trade now. Better to restart and wait for sweep.",
        options: [
          { label: "Restart & wait for sweep", next: "start", branchLabel: "Restart after no sweep" }
        ]
      },

      displacementType: {
        id: "displacementType",
        type: "htf",
        text: "How did price move after the sweep?",
        note: "Impulse: 1â€“3 big body candles with strong FVG. Staircase: multiple pushes with shallow pullbacks. Grindy: overlapping candles, messy.",
        field: "displacementType",
        options: [
          { label: "Impulse leg", value: "impulse", next: "bosDirection", branchLabel: "Displacement: Impulse" },
          { label: "Steplike pump / dump", value: "staircase", next: "bosDirection", branchLabel: "Displacement: Staircase" },
          { label: "Grindy / overlapping", value: "grindy", next: "infoWeakMove", branchLabel: "Displacement: Grindy/Weak" }
        ]
      },

      infoWeakMove: {
        id: "infoWeakMove",
        type: "info",
        text: "Grindy move after a sweep = low-quality context.",
        note: "If displacement is weak, the zone often fails or chops. Best not to force a trade here.",
        options: [
          { label: "Restart and wait for cleaner move", next: "start", branchLabel: "Restart after weak move" }
        ]
      },

      bosDirection: {
        id: "bosDirection",
        type: "htf",
        text: "Did price break structure (BOS) in the direction of that move?",
        note: "Bullish BOS â†’ you look for demand in discount. Bearish BOS â†’ you look for supply in premium.",
        field: "htfBias",
        options: [
          { label: "Bullish BOS (highs taken)", value: "bullish", next: "areaBull", branchLabel: "BOS: Bullish" },
          { label: "Bearish BOS (lows taken)", value: "bearish", next: "areaBear", branchLabel: "BOS: Bearish" },
          { label: "No clean BOS", value: "none", next: "infoNoBos", branchLabel: "BOS: None" }
        ]
      },

      infoNoBos: {
        id: "infoNoBos",
        type: "info",
        text: "No clean BOS = unclear HTF trend.",
        note: "Without trend direction, your SMC zones become random. Skip this setup.",
        options: [
          { label: "Restart & wait for clear BOS", next: "start", branchLabel: "Restart after no BOS" }
        ]
      },

      areaBull: {
        id: "areaBull",
        type: "htf",
        text: "For this bullish BOS, is price now in discount (lower part of the swing)?",
        note: "Demand only makes sense in discount. If you are trying to long in premium, thatâ€™s chasing.",
        field: "htfArea",
        options: [
          { label: "Yes, in discount", value: "discount", next: "zoneType", branchLabel: "Area: Bullish + Discount" },
          { label: "No, mid / premium", value: "wrong", next: "infoWrongArea", branchLabel: "Area: Bullish but wrong" }
        ]
      },

      areaBear: {
        id: "areaBear",
        type: "htf",
        text: "For this bearish BOS, is price now in premium (upper part of the swing)?",
        note: "Supply only makes sense in premium. Shorting discount is risky.",
        field: "htfArea",
        options: [
          { label: "Yes, in premium", value: "premium", next: "zoneType", branchLabel: "Area: Bearish + Premium" },
          { label: "No, mid / discount", value: "wrong", next: "infoWrongArea", branchLabel: "Area: Bearish but wrong" }
        ]
      },

      infoWrongArea: {
        id: "infoWrongArea",
        type: "info",
        text: "You have bias, but price is in the wrong part of the swing.",
        note: "Trading mid-range is gambling. You either wait for price to move to discount/premium or skip.",
        options: [
          { label: "Restart & wait for correct area", next: "start", branchLabel: "Restart from wrong area" }
        ]
      },

      zoneType: {
        id: "zoneType",
        type: "zone",
        text: "What zone are you trying to trade?",
        note: "Reversal at HTF extreme â†’ confirmation entry. Continuation mid-trend â†’ limit is acceptable.",
        field: "zoneType",
        options: [
          { label: "Reversal zone (HTF extreme)", value: "reversal", next: "entryType", branchLabel: "Zone: Reversal" },
          { label: "Continuation zone (trend continuation)", value: "continuation", next: "entryType", branchLabel: "Zone: Continuation" }
        ]
      },

      entryType: {
        id: "entryType",
        type: "entry",
        text: "How do you intend to enter this trade?",
        note: "Reversal + crypto = safer to use LTF confirmation. Strong continuation in obvious trend = limit can work.",
        field: "entryType",
        options: [
          { label: "Confirmation (LTF sweep + CHOCH + OB)", value: "confirmation", next: "slMethod", branchLabel: "Entry: Confirmation" },
          { label: "Limit at zone (no confirmation)", value: "limit", next: "slMethod", branchLabel: "Entry: Limit" }
        ]
      },

      slMethod: {
        id: "slMethod",
        type: "risk",
        text: "How are you placing your stop loss?",
        note: "Best: beyond the liquidity that got swept. Worst: inside the wick that got hunted.",
        field: "slMethod",
        options: [
          { label: "Beyond swept liquidity", value: "beyond_sweep", next: "tpMethod", branchLabel: "SL: Beyond sweep" },
          { label: "Just under/over OB", value: "under_ob", next: "infoTightSl", branchLabel: "SL: Under/over OB only" }
        ]
      },

      infoTightSl: {
        id: "infoTightSl",
        type: "info",
        text: "You are putting SL just under/over the OB.",
        note: "This often gets wicked. In SMC, the safer stop is beyond the liquidity that was actually taken.",
        options: [
          { label: "Iâ€™ll move SL beyond liquidity", next: "slMethodAdjusted", branchLabel: "Adjust SL" },
          { label: "I insist on tight SL", next: "tpMethod", branchLabel: "Accept tight SL risk" }
        ]
      },

      slMethodAdjusted: {
        id: "slMethodAdjusted",
        type: "risk",
        text: "SL will be moved beyond the swept liquidity.",
        note: "RR might be smaller, but survivability is higher.",
        field: "slMethod",
        options: [
          { label: "Confirm SL beyond liquidity", value: "beyond_sweep", next: "tpMethod", branchLabel: "SL: Adjusted beyond sweep" }
        ]
      },

      tpMethod: {
        id: "tpMethod",
        type: "risk",
        text: "How are you planning to take profit?",
        note: "Structure-based exits beat emotional exits.",
        field: "tpMethod",
        options: [
          { label: "TP1 FVG fill, TP2 next liquidity", value: "fvg_liquidity", next: "endReady", branchLabel: "TP: FVG + Liquidity" },
          { label: "Single TP at major liquidity", value: "single_liquidity", next: "endReady", branchLabel: "TP: Single liquidity" },
          { label: "No clear plan yet", value: "no_plan", next: "infoNoTpPlan", branchLabel: "TP: No plan" }
        ]
      },

      infoNoTpPlan: {
        id: "infoNoTpPlan",
        type: "info",
        text: "You donâ€™t have a clear TP plan.",
        note: "Youâ€™re about to trade without an exit idea. Either define a plan now or donâ€™t take this trade.",
        options: [
          { label: "Fine, Iâ€™ll plan TP as FVG + liquidity", next: "tpMethodForced", branchLabel: "Force TP plan" },
          { label: "I accept that this is low quality", next: "endReady", branchLabel: "Proceed without strong TP plan" }
        ]
      },

      tpMethodForced: {
        id: "tpMethodForced",
        type: "risk",
        text: "TP1 at nearest FVG fill, TP2 at next clear liquidity pool.",
        note: "This is the default smart plan: partial out at rebalancing, then at main target.",
        field: "tpMethod",
        options: [
          { label: "Confirm this TP plan", value: "fvg_liquidity", next: "endReady", branchLabel: "TP: Forced FVG + Liquidity" }
        ]
      },

      endReady: {
        id: "endReady",
        type: "end",
        text: "This setup is now defined. You can store it in your journal and execute according to this plan.",
        note: "You still have to obey it in real time. But the logic is now structured instead of emotional.",
        options: [
          { label: "Review summary & Save trade", next: "saveStep", branchLabel: "Go to Save" }
        ]
      },

      saveStep: {
        id: "saveStep",
        type: "end",
        text: "If youâ€™re satisfied with this plan, click â€œSave Trade to Journalâ€.",
        note: "When logged in, it saves to Firestore. When logged out, it saves locally.",
        options: [
          { label: "Back to previous step", next: "endReady", branchLabel: "Back before save" }
        ]
      }
    };

    // ===== Wizard state =====
    let currentNodeId = "start";
    let path = [];
    let currentTrade = { marketType: "crypto" };

    function humanReadableType(type) {
      if (type === "context") return "Phase 0: Context";
      if (type === "htf") return "Phase 1: HTF Bias";
      if (type === "zone") return "Phase 2: Zone Selection";
      if (type === "entry") return "Phase 3: Entry Model";
      if (type === "risk") return "Phase 4: Risk & TP";
      if (type === "end") return "Phase 5: Finalization";
      return "Info / Reminder";
    }

    function updateBiasLabel() {
      const bias = currentTrade.htfBias;
      if (!bias) {
        biasLabelEl.textContent = "Bias: â€“";
        biasLabelEl.style.borderColor = "rgba(148,163,184,0.6)";
      } else if (bias === "bullish") {
        biasLabelEl.textContent = "Bias: Bullish";
        biasLabelEl.style.borderColor = "rgba(34,197,94,0.9)";
      } else if (bias === "bearish") {
        biasLabelEl.textContent = "Bias: Bearish";
        biasLabelEl.style.borderColor = "rgba(239,68,68,0.9)";
      } else {
        biasLabelEl.textContent = "Bias: " + bias;
      }
    }

    function updateSummary() {
      summaryPairEl.textContent = "Pair: " + (currentTrade.pair || "â€“");
      summarySessionEl.textContent = "Session: " + (currentTrade.session || "â€“");
      summaryBiasEl.textContent = "HTF Bias: " + (currentTrade.htfBias || "â€“");
      summaryDisplacementEl.textContent = "Displacement: " + (currentTrade.displacementType || "â€“");
      summaryZoneEl.textContent = "Zone Type: " + (currentTrade.zoneType || "â€“");
      summaryEntryEl.textContent = "Entry Type: " + (currentTrade.entryType || "â€“");
      summarySlEl.textContent = "SL Method: " + (currentTrade.slMethod || "â€“");
      summaryTpEl.textContent = "TP Method: " + (currentTrade.tpMethod || "â€“");
      summaryScoreEl.textContent = "Setup Score: " + (
        currentTrade.setupScore != null ? currentTrade.setupScore + "/10" : "â€“"
      );
    }

    function renderCurrentNode() {
      const node = nodes[currentNodeId];
      if (!node) {
        alert("Internal error: node '" + currentNodeId + "' not found.");
        return;
      }

      nodeTextEl.textContent = node.text;
      nodeNoteEl.textContent = node.note || "";
      nodeTypeLabelEl.textContent = humanReadableType(node.type);
      updateBiasLabel();
      updateSummary();

      if (node.type === "context") {
        statusLineTextEl.textContent = "Context: define pair and session first.";
      } else if (node.type === "htf") {
        statusLineTextEl.textContent = "HTF phase: structure + displacement. No LTF noise yet.";
      } else if (node.type === "zone") {
        statusLineTextEl.textContent = "Zone phase: Reversal vs Continuation.";
      } else if (node.type === "entry") {
        statusLineTextEl.textContent = "Entry phase: confirmation vs limit.";
      } else if (node.type === "risk") {
        statusLineTextEl.textContent = "Risk phase: SL and TP rules.";
      } else if (node.type === "end") {
        statusLineTextEl.textContent = "Finalize and save or adjust.";
      } else {
        statusLineTextEl.textContent = "Info step. Read it fully.";
      }

      optionsContainerEl.innerHTML = "";
      node.options.forEach((opt, i) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn " + (i === 0 ? "btn-primary" : "btn-outline");
        btn.textContent = opt.label;
        btn.onclick = () => handleOptionClick(node, opt);
        optionsContainerEl.appendChild(btn);
      });

      saveContainerEl.innerHTML = "";
      if (node.id === "saveStep") {
        const saveBtn = document.createElement("button");
        saveBtn.type = "button";
        saveBtn.className = "btn btn-primary";
        saveBtn.textContent = "ðŸ’¾ Save Trade to Journal";
        saveBtn.onclick = saveCurrentTrade;
        saveContainerEl.appendChild(saveBtn);
      }

      backBtnEl.disabled = path.length === 0;
      backBtnEl.style.opacity = backBtnEl.disabled ? 0.4 : 1;
    }

    function handleOptionClick(node, option) {
      path.push({
        nodeId: node.id,
        text: node.text,
        branchLabel: option.branchLabel || option.label
      });

      if (node.field) {
        currentTrade[node.field] = option.value || option.label;
      }
      if (node.field === "htfBias") {
        currentTrade.htfBias = option.value;
      }

      currentNodeId = option.next;
      renderCurrentNode();
    }

    function restartWizard() {
      path = [];
      currentTrade = { marketType: "crypto" };
      currentNodeId = "start";
      renderCurrentNode();
    }

    function goBack() {
      if (path.length === 0) return;

      path.pop();
      currentTrade = { marketType: "crypto" };
      currentNodeId = "start";

      for (let i = 0; i < path.length; i++) {
        const step = path[i];
        const node = nodes[currentNodeId];
        if (!node) break;

        let chosenOption = null;
        for (let j = 0; j < node.options.length; j++) {
          const opt = node.options[j];
          if (opt.branchLabel === step.branchLabel) {
            chosenOption = opt;
            break;
          }
        }
        if (!chosenOption) break;

        if (node.field) {
          currentTrade[node.field] = chosenOption.value || chosenOption.label;
        }
        if (node.field === "htfBias") {
          currentTrade.htfBias = chosenOption.value;
        }

        currentNodeId = chosenOption.next;
      }

      renderCurrentNode();
    }

    backBtnEl.onclick = goBack;
    restartBtnEl.onclick = restartWizard;

    // ===== Scoring =====
    function calculateSetupScore(trade) {
      let score = 0;

      if (trade.htfSweep === "yes") score += 2;

      if (trade.displacementType === "impulse") score += 2;
      else if (trade.displacementType === "staircase") score += 1;

      if (trade.htfBias === "bullish" && trade.htfArea === "discount") score += 2;
      if (trade.htfBias === "bearish" && trade.htfArea === "premium") score += 2;

      if (trade.zoneType === "reversal" || trade.zoneType === "continuation") score += 1;

      if (trade.entryType === "confirmation") score += 2;
      else if (trade.entryType === "limit") score += 1;

      if (trade.slMethod === "beyond_sweep") score += 1;

      if (trade.tpMethod === "fvg_liquidity" || trade.tpMethod === "single_liquidity") score += 1;

      if (score < 0) score = 0;
      if (score > 10) score = 10;
      return score;
    }

    // ===== Local storage helpers =====
    function loadTradesLocal() {
      try {
        const raw = localStorage.getItem("trades");
        if (!raw) return [];
        return JSON.parse(raw) || [];
      } catch {
        return [];
      }
    }

    function saveTradesLocal(allTrades) {
      try {
        localStorage.setItem("trades", JSON.stringify(allTrades));
      } catch {}
    }

    function clearLocalTrades() {
      localStorage.removeItem("trades");
    }

    // ===== Firestore helpers =====
    async function loadTradesFirestore() {
      if (!currentUser) return [];
      const q = query(
        collection(db, "trades"),
        where("userId", "==", currentUser.uid),
        orderBy("createdAt", "desc")
      );
      const snap = await getDocs(q);
      const arr = [];
      snap.forEach(docSnap => {
        arr.push({ docId: docSnap.id, ...docSnap.data() });
      });
      tradesCache = arr;
      return arr;
    }

    async function saveTradeFirestore(trade) {
      if (!currentUser) return;
      await addDoc(collection(db, "trades"), {
        userId: currentUser.uid,
        ...trade
      });
    }

    async function updateTradeFirestore(docId, partial) {
      if (!currentUser || !docId) return;
      const ref = doc(db, "trades", docId);
      await updateDoc(ref, partial);
    }

    // ===== Stats & journal rendering =====
    function updateStats(trades) {
      const total = trades.length;
      statsTotalEl.textContent = "Trades: " + total;

      if (!total) {
        statsWinrateEl.textContent = "Winrate: â€“";
        statsAvgREl.textContent = "Avg R: â€“";
        return;
      }

      let wins = 0;
      let losses = 0;
      let sumR = 0;
      let rCount = 0;

      for (const t of trades) {
        if (t.result === "win") wins++;
        else if (t.result === "loss") losses++;

        if (t.rrAchieved != null && !isNaN(t.rrAchieved)) {
          sumR += Number(t.rrAchieved);
          rCount++;
        }
      }

      const denom = wins + losses;
      if (denom === 0) {
        statsWinrateEl.textContent = "Winrate: â€“";
      } else {
        const wr = (wins / denom) * 100;
        statsWinrateEl.textContent = "Winrate: " + wr.toFixed(1) + "%";
      }

      if (rCount === 0) {
        statsAvgREl.textContent = "Avg R: â€“";
      } else {
        const avgR = sumR / rCount;
        statsAvgREl.textContent = "Avg R: " + avgR.toFixed(2);
      }
    }

    async function renderJournal() {
      let trades;
      if (currentUser) {
        trades = await loadTradesFirestore();
      } else {
        trades = loadTradesLocal();
      }

      journalBodyEl.innerHTML = "";
      updateStats(trades);

      if (!trades.length) {
        journalEmptyEl.style.display = "block";
        return;
      }
      journalEmptyEl.style.display = "none";

      trades.forEach((t, index) => {
        const tr = document.createElement("tr");

        const dateTd = document.createElement("td");
        dateTd.textContent = t.createdAt ? t.createdAt.split("T")[0] : "-";
        tr.appendChild(dateTd);

        const pairTd = document.createElement("td");
        pairTd.textContent = t.pair || "-";
        tr.appendChild(pairTd);

        const biasTd = document.createElement("td");
        biasTd.textContent = t.htfBias || "-";
        tr.appendChild(biasTd);

        const zoneTd = document.createElement("td");
        zoneTd.textContent = t.zoneType || "-";
        tr.appendChild(zoneTd);

        const entryTd = document.createElement("td");
        entryTd.textContent = t.entryType || "-";
        tr.appendChild(entryTd);

        const scoreTd = document.createElement("td");
        scoreTd.textContent = t.setupScore != null ? t.setupScore + "/10" : "-";
        tr.appendChild(scoreTd);

        const resultTd = document.createElement("td");
        const pill = document.createElement("span");
        const r = t.result || "";
        if (r === "win") {
          pill.className = "pill pill-win";
          pill.textContent = "WIN";
        } else if (r === "loss") {
          pill.className = "pill pill-loss";
          pill.textContent = "LOSS";
        } else if (r === "be") {
          pill.className = "pill pill-be";
          pill.textContent = "B/E";
        } else {
          pill.textContent = "-";
        }
        resultTd.appendChild(pill);
        tr.appendChild(resultTd);

        const rrTd = document.createElement("td");
        rrTd.textContent = t.rrAchieved != null ? t.rrAchieved : "-";
        tr.appendChild(rrTd);

        const actionsTd = document.createElement("td");
        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "btn btn-ghost";
        editBtn.textContent = "Edit";
        editBtn.onclick = () => editTrade(index);
        actionsTd.appendChild(editBtn);
        tr.appendChild(actionsTd);

        journalBodyEl.appendChild(tr);
      });
    }

    async function saveCurrentTrade() {
      const trade = JSON.parse(JSON.stringify(currentTrade));
      trade.marketType = "crypto";
      trade.createdAt = new Date().toISOString();
      trade.result = null;
      trade.rrAchieved = null;
      trade.setupScore = calculateSetupScore(trade);

      if (currentUser) {
        await saveTradeFirestore(trade);
      } else {
        const allTrades = loadTradesLocal();
        allTrades.push(trade);
        saveTradesLocal(allTrades);
      }

      await renderJournal();
      alert("Trade saved with score " + trade.setupScore + "/10.");
      restartWizard();
    }

    async function editTrade(index) {
      let trades;
      if (currentUser) {
        trades = tradesCache;
      } else {
        trades = loadTradesLocal();
      }
      if (!trades || index < 0 || index >= trades.length) return;
      const t = trades[index];

      let result = prompt("Result? (win/loss/be)", t.result || "");
      if (result !== null) {
        result = result.toLowerCase().trim();
        if (result && !["win", "loss", "be"].includes(result)) {
          alert("Invalid result. Use win, loss, or be.");
          return;
        }
        t.result = result || null;
      }

      const rrStr = prompt("R multiple achieved? (e.g. 1.5, -0.5)", t.rrAchieved != null ? t.rrAchieved : "");
      if (rrStr !== null && rrStr.trim() !== "") {
        const rr = parseFloat(rrStr);
        if (!isNaN(rr)) {
          t.rrAchieved = rr;
        }
      }

      if (currentUser) {
        tradesCache[index] = t;
        await updateTradeFirestore(t.docId, {
          result: t.result || null,
          rrAchieved: t.rrAchieved != null ? t.rrAchieved : null
        });
      } else {
        const allTrades = loadTradesLocal();
        allTrades[index] = t;
        saveTradesLocal(allTrades);
      }

      await renderJournal();
    }

    clearBtnEl.onclick = () => {
      if (!currentUser) {
        if (confirm("Clear ALL saved trades from local storage on this device?")) {
          clearLocalTrades();
          renderJournal();
        }
      } else {
        alert("Clear All is only for local mode. For Firestore, delete trades manually later (we can add a bulk delete button in another version).");
      }
    };

    // ===== Auth logic =====
    function updateAuthUI() {
      if (currentUser) {
        authStatusEl.textContent = "Logged in as " + (currentUser.email || currentUser.uid);
        loginBtnEl.disabled = true;
        registerBtnEl.disabled = true;
        logoutBtnEl.disabled = false;
        authEmailEl.disabled = true;
        authPasswordEl.disabled = true;
      } else {
        authStatusEl.textContent = "Not logged in (local mode)";
        loginBtnEl.disabled = false;
        registerBtnEl.disabled = false;
        logoutBtnEl.disabled = true;
        authEmailEl.disabled = false;
        authPasswordEl.disabled = false;
      }
    }

    loginBtnEl.onclick = async () => {
      const email = authEmailEl.value.trim();
      const pwd = authPasswordEl.value.trim();
      if (!email || !pwd) {
        alert("Enter email and password.");
        return;
      }
      try {
        await signInWithEmailAndPassword(auth, email, pwd);
      } catch (e) {
        alert("Login error: " + e.message);
      }
    };

    registerBtnEl.onclick = async () => {
      const email = authEmailEl.value.trim();
      const pwd = authPasswordEl.value.trim();
      if (!email || !pwd) {
        alert("Enter email and password.");
        return;
      }
      try {
        await createUserWithEmailAndPassword(auth, email, pwd);
        alert("Registered. You are now logged in.");
      } catch (e) {
        alert("Register error: " + e.message);
      }
    };

    logoutBtnEl.onclick = async () => {
      try {
        await signOut(auth);
      } catch (e) {
        alert("Logout error: " + e.message);
      }
    };

    onAuthStateChanged(auth, async (user) => {
      currentUser = user || null;
      updateAuthUI();
      await renderJournal();
    });

    // init
    restartWizard();
    renderJournal();
  </script>
</body>
</html></html>
